<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Gloval Vectors for Word Representation, GloVe | DECISION J</title>
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Gloval Vectors for Word Representation, GloVe">
<meta name="author" content="HaeYong JOUNG">
<meta property="og:locale" content="en_US">
<meta name="description" content="GloVe 이해하기!">
<meta property="og:description" content="GloVe 이해하기!">
<link rel="canonical" href="http://localhost:4000/text-mining/2019/05/16/Gloval-Vectors-for-Word-Representation,-GloVe.md.html">
<meta property="og:url" content="http://localhost:4000/text-mining/2019/05/16/Gloval-Vectors-for-Word-Representation,-GloVe.md.html">
<meta property="og:site_name" content="DECISION J">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-05-16T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Gloval Vectors for Word Representation, GloVe">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"HaeYong JOUNG"},"dateModified":"2019-05-16T00:00:00+09:00","datePublished":"2019-05-16T00:00:00+09:00","description":"GloVe 이해하기!","headline":"Gloval Vectors for Word Representation, GloVe","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/text-mining/2019/05/16/Gloval-Vectors-for-Word-Representation,-GloVe.md.html"},"url":"http://localhost:4000/text-mining/2019/05/16/Gloval-Vectors-for-Word-Representation,-GloVe.md.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="https://decision-J.github.io/assets/letter-j.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="DECISION  J">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>


<link rel="apple-touch-icon" sizes="180x180" href="https://decision-J.github.io/assets/logo.ico/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://decision-J.github.io/assets/logo.ico/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://decision-J.github.io/assets/logo.ico/favicon-16x16.png">
<link rel="manifest" href="https://decision-J.github.io/assets/logo.ico/site.webmanifest">
<link rel="mask-icon" href="https://decision-J.github.io/assets/logo.ico/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="DECISION  J" src="https://decision-J.github.io/assets/letter-j.png" onerror="this.style.display='none'">
  
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">Gloval Vectors for Word Representation, GloVe</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2019-05-16T00:00:00+09:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 16, 2019
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 4 mins</span>
  </p>
<div class="post-tags"><a class="post-tag" href="/tags.html#text-mining">#text-mining</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h1 id="glove-이해하기">GloVe 이해하기!</h1>

<p>​</p>

<p>​	이번 포스팅은 Word representation의 한 방법론인 GloVe에 대해서 알아보도록 하겠습니다.</p>

<p>GloVe는 Word embedding 방법 중 Distributed representation에 해당하는 방법론으로, 기존의 Word2Vec이나 LSA와 같은 알고리즘이 가지고 있던 한계점들을 보완하여 개발한 알고리즘입니다.</p>

<p>본 글에서는 GloVe가 기존 알고리즘에 비해 어떤 이 점을 갖는지, 어떤 프로세스를 거쳐 텍스트의 Distributed form을 찾게 되는 지 등에 대해 살펴보도록 하겠습니다.</p>

<hr>

<h3 id="distributed-representation">Distributed Representation</h3>

<p>​	<strong>Word representation</strong> 방법의 초기 모델은 <strong>WordNet</strong>이나 <strong>One-hot Vector</strong> 방법이 있습니다. 이 방법론들은 분석자가 미리 단어의 사전적 뜻을 정해두어 표현하거나, 단순 1,0 변환으로 표현하는 것입니다. 이는 비교적 직관적인 이해를 하기에 용이하나 단어의 분포적 특성을 파악하지 못하므로 단어들의 관계나 동명이의어 등을 쉽게 파악해내지 못합니다. 이에 보다 발전적인 방법론이 대두된 것이 <strong>Distributed Representation</strong> 방법입니다. Distributed Representation은 말뭉치(Corpus)를 기반으로 단어의 출현 빈도를 Word vector로 변환하여 학습하는 방법입니다. 이 전 방법론에 비해 단어의 관계를 표현하는것이 가능하며, 사람의 주관적 개입도 최소화할 수 있다는 장점을 가지고 있습니다. Distributed Representation의 대표적인 알고리즘으로는 <strong>Word2Vec</strong>과 <strong>LSA</strong>를 들 수 있습니다.(본 포스팅에서 다루는 GloVe도 포함됩니다.)</p>

<p>​	하지만 이러한 Word2Vec과 LSA에도 단점이 존재합니다. 먼저 Word2Vec의 경우 중심단어로부터 사용자가 지정한 window내에서만 관계를 파악하여 분석하기 때문에 Corpus 전체의 통계정보, 즉, <u>Co-occurrence 정보를 반영하지 못하는 단점</u>이 있습니다. 더하여 한 번에 하나의 계산만 수행하기 때문에 업데이트에 어려움이 있습니다. 다음으로 LSA의 경우 Corpus 전체의 Co-occurrence 정보는 모두 반영되는 대신, <u>단어 간 유사도나 관계에 대해서는 파악하기 어려운 단점</u>을 가집니다.</p>

<p>​	<strong>GloVe</strong>는 이러한 단점들을 보완하여 발전시킨 방법론이라 할 수 있습니다. 즉, <strong>Corpus 전체의 Co-occurrecnce는 모두 반영하면서 단어간 유사도도 측정할 수 있는 방법론</strong>이라 할 수 있습니다.</p>

<h3 id="how-to-do-that--probability-of-co-occurrence">How to do that?  “Probability of Co-Occurrence”</h3>

<p>​	위의 단점들을 해결하는 방법으로 GloVe 연구팀이 제시한 것이 바로 <strong>“동시등장확률(Probability of Co-occurrence)”</strong>입니다. 먼저 논문 속 예시를 보며 살펴보겠습니다.</p>

<p><img src="https://hyj0103.github.io/assets/Glove.jpg" alt="PR"></p>

<p>​	위의 표 중 첫 번째와 두 번째 row는 각각 ice과 steam이라는 단어가 주어졌을 때, k 단어가 나타날 확률을 나타냅니다. 예시에서는 k로 solid, gas, water, fashion이 주어져 있습니다. 마지막 세 번째 row에는 1, 2 row의 비로 표현됩니다. 각각의 값을 살펴보면 solid는 ice가 조건부 확률로 주어졌을 경우가 steam의 경우보다 더 등장확률이 높은 것을 알 수 있습니다. gas의 경우 solid와 반대로 나타나게 됩니다. 또한 ice, steam모두 관련이 있는 water / 모두 관련이 없는 fashion의 등장확률은 1, 2 행의 값이 비슷하게 나타나게 됩니다.</p>

<p>​	따라서 우리가 주목해야할 지점은 3번째 행입니다. 분자의 확률이 분모보다 더 클 경우, 즉 본 예시에서는 k 단어가 steam보다 ice에 더 연관이 많을 경우 해당 값은 1보다 큰 값으로 도출됩니다. (분모, 분자 차이가 클수록 값이 더 커져갑니다.) 반대의 경우에는 1보다 작은 값을 가지게 됩니다. 또한 3, 4번째 열과 같이 조건부 단어에 둘다 관련이 없거나 둘다 관련이 있는 경우(water, fashion) 1과 비슷한 값을 가지게 됩니다. 이 것이 바로 <strong>동시등장확률</strong>입니다.</p>

<p>​	GloVe 방법론은 Corpus전체에서 위와 같은 단어 간의 동시등장확률을 계산하여 단어들을 표현해내게 됩니다. 이에 따라 앞서 언급하였 듯, Corpus 전체의 Co-occurrence를 반영하면서도 단어 간의 관계를 표현해낼 수 있게 되는 것입니다.</p>

<h3 id="process-of-glove">Process of GloVe</h3>

<p>​	그렇다면 동시등장확률을 활용하여 텍스트를 학습하는 <strong>목적함수(Objective function)</strong>를 알아보겠습니다. 동시등장확률을 이용한 목적함수를 수식으로 표현해보면 아래와 같습니다. (기본적인 notation은 위의 예시에서와 동일하게 사용)</p>

<p><img src="https://hyj0103.github.io/assets/glove2.jpg" alt="ojf1"></p>

<p>​	위 수식을 살펴보면, 어떠한 단어 벡터 K가 주어졌을 때 i, j 와의 관계에 대한 비를 구하는 함수 F를 의미합니다. 여기서 함수 F가 바로 우리가 구하고자 하는 목적함수가 될 것입니다. 위 수식을 차근차근 재표현해보도록 하겠습니다.</p>

<p><img src="https://hyj0103.github.io/assets/glove3.jpg" alt="ojf2"></p>

<p>​	첫 번째 수식부터 살펴보도록 하겠습니다. 먼저 우리가 관심있는 i와 j 단어 벡터의 관계를 linear space에서 가장 쉽게 표현할 수 있는 방법인 차를 이용하여 함수를 구성합니다. 그 다음으로 scalar인 확률 값을 계산해주기 위하여 두 벡터를 내적한 값으로 표현하였습니다. 이 때, 두 번째 수식에서 우변에 나타난 확률 값의 비를 우리가 구하고자 하는 목적함수로 표현해주면 보다 손쉽게 단어 간의 관계를 파악할 수 있겠다는 아이디어로 i, j와 k를 내적한 값을 목적함 수에 넣어주는 형태로 표현을 하게 됩니다.</p>

<p>​	최종 수식을 만족하는 목적함수를 구하려면, 다음의 조건을 만족해야 합니다. 먼저 첫 째로, corpus상에서 i 단어 벡터는 언제든지 k 단어 벡터로 변환될 수 있어야 합니다. 또한 co-occurrence matrix가 symmetric하다는 것을 반영할 수 있어야 하며,  마지막 수식에서 나타난 것과 같이 함수 내 값의 차가 함수의 비로 표현되는 homomorphism 조건을 만족해야 합니다. 우리는 이 조건을 모두 만족하는 함수가 <strong>지수함수</strong>임을 알고 있습니다. 따라서 지수함수를 이용하여 위 식을 표현해보겠습니다.</p>

<p><img src="https://hyj0103.github.io/assets/glove4.jpg" alt="obj3"></p>

<p>​</p>

<p>​	이 때, 두 번째 수식의 우변의 경우 위에서 언급한 것처럼 언제든 k와 i가 바뀔 수 있기 때문에 k와 i가 교체되더라도 바뀌지 않도록 수식을 로그가 아닌 <strong>상수 b</strong>로 재 표현해줍니다.</p>

   																	 <img src="https://hyj0103.github.io/assets/glove5.jpg" alt="ojf4">

<p>​	따라서 최종 수식에서 우변을 좌변으로 이항시키면 우리는 원하던 목적함수를 얻을 수 있습니다. 여기에 GloVe 연구팀은 조건식을 하나 더 추가해줍니다. 바로 대량으로 등장하는 단어들에 cap을 걸어주기 위함인데요. 만약 주어진 corpus 내에  굉장히 잦은 빈도로 출현하는 단어의 경우 우리의 목적 함수에서 noise가 될 수 있습니다. (제곱 term으로 빈도수가 높다면 목적함수의 값이 커질 것이므로) 따라서 단어의 빈도수가 아무리 많더라도 1에 cap을 걸어줌으로써 해당 단어에 대한 Overfitting을 방지하는 역할을 하는 <strong>f(X) term</strong>을 추가해서 곱해주게 됩니다.</p>

<p><img src="https://hyj0103.github.io/assets/glove6.jpg" alt="final"></p>

<p>​		<em>※ f(X) term의 알파의 경우 hyper parameter입니다. 논문에 따르면 simulation 결과, 알파가 3/4 일 때 가장 최상의 결과를 낸다고 주어져 있습니다.</em></p>

<p>​</p>

<p>### GloVe 실습</p>

<p>​</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/text-mining/2019/04/05/NLP,-TextMining-Start!.md.html" title="NLP, Text mining start!">NLP, Text mining start!</a><a class="next" href="/competition/2020/02/20/Walmart-Saletype-Classification.md.html" title="[Kaggle] Walmart SaleType Classification">[Kaggle] Walmart SaleType Classification</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/computer-vision/2021/04/28/Coursera-ComputerVision-course.html" title="[Kaggle] Walmart SaleType Classification">Coursera Computer Vision Course 과제 정리</a></li>
<li><a class="post-link" href="/competition/2020/06/19/COVID-19-Modeling.html" title="[Kaggle] Walmart SaleType Classification">[Dacon] COVID-19 Modeling</a></li>
<li><a class="post-link" href="/papers/2021/08/03/Yolo_v3_review.html" title="[Kaggle] Walmart SaleType Classification">[CV] YOLO v3</a></li>
<li><a class="post-link" href="/statistics/2021/07/28/Narrow-Confidence-Interval-for-low-N-&amp;-small-p.html" title="[Kaggle] Walmart SaleType Classification">Narrow Confidence Interval for low N &amp; small p</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2019-2022 decision-J</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
